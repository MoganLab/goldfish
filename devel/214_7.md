# [214_7]

## 任务相关的代码文件
- goldfish/liii/njson.scm
- src/goldfish.hpp
- tests/goldfish/liii/njson-test.scm
- devel/214_7.md

## 如何测试
```bash
xmake b goldfish
bin/goldfish tests/goldfish/liii/njson-test.scm
```

## 2026/2/26 新增 njson 容器查询与文件读写接口

### What
1. Scheme API 扩展：
   在 `goldfish/liii/njson.scm` 新增并导出以下接口：
   - `njson-size`
   - `njson-empty?`
   - `njson-file->json`
   - `njson-json->file`
2. C++ 原语扩展：
   在 `src/goldfish.hpp` 新增 `g_njson-size`、`g_njson-empty?` 以及对应实现函数，
   并在 `glue_njson` 中完成注册。
3. 测试扩展：
   在 `tests/goldfish/liii/njson-test.scm` 增加上述接口的文档注释与单测，覆盖：
   - object/array/scalar 的 `size/empty?` 返回值；
   - 非法输入与释放后句柄的 `type-error`；
   - 文件写入后读取回环验证；
   - 标量 `'null` 的文件写读场景。

### Why
1. `njson` 之前缺少容器规模查询能力，调用方需要手写 `keys` 或额外逻辑判断空值，使用成本偏高。
2. JSON 文件落盘与加载是常见场景，缺少直接 API 会导致业务层重复拼装 `path-read-text` / `path-write-text` 与序列化逻辑。
3. 将文件 I/O 与序列化能力纳入 `njson`，可以统一参数校验和错误语义，减少调用方分散处理。

### How
1. `njson-size` / `njson-empty?`：
   - Scheme 层先做 `njson-handle` 校验，再调用 `g_njson-size` / `g_njson-empty?`；
   - C++ 层对非法或已释放句柄统一返回 `type-error`；
   - 语义定义：
     - object/array：按容器语义返回真实 `size/empty`；
     - 其他类型：`size = 0`，`empty? = #t`。
2. `njson-file->json`：
   - 校验 `path` 为字符串；
   - 读取文本 `path-read-text` 后交给 `njson-string->json` 解析；
   - 文件不存在或 JSON 非法时沿用原有错误类型抛出。
3. `njson-json->file`：
   - 校验 `path` 为字符串，`value` 为 `njson-handle` 或严格 JSON 标量；
   - 先 `njson-json->string`，再 `path-write-text`；
   - 返回写入字节数，便于调用方做结果判定。

### 兼容性说明
1. 本次仅新增接口，不改变既有 `njson` API 语义。
2. 新接口参数错误仍使用 `type-error`，与现有 `njson` 风格一致。
3. 文件接口复用现有序列化/反序列化路径，错误行为与 `njson-string->json`、`njson-json->string` 保持一致。

## 验证结果
本次文档编写前已执行：
1. ✅ `xmake b goldfish` 通过。
2. ✅ `bin/goldfish tests/goldfish/liii/njson-test.scm` 通过。
3. ✅ 输出：`; *** checks *** : 179 correct, 0 failed.`
