# [214_6]

## 任务相关的代码文件
- goldfish/liii/njson.scm
- src/goldfish.hpp
- tests/goldfish/liii/njson-test.scm
- devel/214_6.md

## 如何测试
```bash
xmake b goldfish
bin/goldfish tests/goldfish/liii/njson-test.scm
```

## 2026/2/26 新增 njson 类型谓词接口

### What
1. Scheme API 扩展：
   在 `goldfish/liii/njson.scm` 新增并导出以下接口：
   - `njson-null?`
   - `njson-object?`
   - `njson-array?`
   - `njson-string?`
   - `njson-number?`
   - `njson-integer?`
   - `njson-boolean?`
2. C++ 原语扩展：
   在 `src/goldfish.hpp` 新增对应的 `g_njson-*?` 原语与注册逻辑，
   并复用统一执行函数 `njson_run_value_type_predicate`。
3. 测试扩展：
   在 `tests/goldfish/liii/njson-test.scm` 新增类型谓词测试块，覆盖：
   - handle 输入判定；
   - 标量输入判定；
   - 释放后句柄判定（应抛 `type-error`）。

### Why
1. `njson` 之前缺少基础类型谓词，调用方需要自己 `njson-ref` 后再手动判型，接口不完整。
2. JSON 处理场景里，类型判断是高频操作，补齐谓词可直接降低业务层样板代码。
3. 统一在 C++ 层收敛谓词执行逻辑，可避免 7 个接口重复实现参数校验与句柄状态检查。

### How
1. 新增统一谓词执行器 `njson_run_value_type_predicate`：
   - 非 handle 输入：直接走标量谓词分支，返回 `#t/#f`；
   - handle 输入：执行 handle-id 提取、释放态校验、底层 `json` 类型判定。
2. 7 个谓词各自只传入“handle 判定器 + scalar 判定器”：
   - handle 侧使用 `nlohmann::json` 的 `is_*` 系列接口；
   - scalar 侧使用 `s7` 的 `s7_is_*` 判定或 `null` symbol 判定。
3. Scheme 层保持轻封装：
   `njson-xxx?` 直接代理到 `g_njson-xxx?`，不增加额外类型拦截。

### 兼容性说明
1. 仅新增 API，不改变既有 `njson` 接口行为。
2. 对已释放/非法 handle 的错误语义保持一致，仍抛 `type-error`。
3. 对非 handle 输入，谓词按 JSON 标量语义返回布尔值，不抛错。

## 验证结果
本次文档编写前已执行：
1. ✅ `xmake b goldfish` 通过。
2. ✅ `bin/goldfish tests/goldfish/liii/njson-test.scm` 通过。
3. ✅ 输出：`; *** checks *** : 157 correct, 0 failed.`

