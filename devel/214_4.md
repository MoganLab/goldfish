# [214_4]

## 任务相关的代码文件
- bench/njson-bench.scm
- goldfish/liii/njson.scm
- src/goldfish.hpp
- tests/goldfish/liii/njson-test.scm
- devel/214_4.md

## 如何测试
```bash
xmake b goldfish
bin/goldfish tests/goldfish/liii/njson-test.scm
bin/goldfish bench/njson-bench.scm
```

## 2026/2/26 新增`njson-set!`，`njson-push!`，`njson-drop!`并优化`json-keys`

### What
1. Scheme API：
   在 `goldfish/liii/njson.scm` 新增并导出 `njson-set!`、`njson-push!`、`njson-drop!`，保持与 `njson-set/push/drop` 一致的调用风格，并在入口保留 `njson?` 参数校验。
2. C++ 运行时：
   在 `src/goldfish.hpp` 注册 `g_njson-set!`、`g_njson-push!`、`g_njson-drop!` 原语；
   将 `set/push/drop` 与 `set!/push!/drop!` 重构为统一执行链：
   `njson_parse_update_request` -> `njson_apply_update_on_root` -> `njson_run_update`。
3. keys 性能优化：
   新增按 handle-id 的 `njson-keys` 缓存（`njson_keys_cache_*` 三组表），`f_njson_keys` 命中缓存直接返回；
   在 `f_njson_free` 中清理缓存并 `gc_unprotect`；
   在 `set!/push!/drop!` 原地更新成功后，若缓存存在则立即重算。
4. 测试补充：
   在 `tests/goldfish/liii/njson-test.scm` 增加 `njson-set!/push!/drop!` 单测和文档注释；
   新增 `njson-keys` 缓存刷新路径测试（先命中缓存，再执行可变更新，验证 keys 结果同步）。
5. 基准扩展：
   在 `bench/njson-bench.scm` 增加 `njson-set!`、`njson-push!+drop!`、`njson-set!+drop!` 指标与输出，
   并将原地接口对比口径调整为 `liii-set/push/drop` 对 `njson` 可变路径。

### Why
1. `set/push/drop` 仅函数式复制更新时，写路径性能收益受整棵复制成本限制。
2. `set!/push!/drop!` 与非 `!` 版本逻辑高度重复，维护成本高，容易分支漂移。
3. `njson-keys` 在同一 handle 上重复调用时会重复构造 string+cons，跨语言分配成本显著。
4. 需要通过单测和基准同时验证：
   可变接口语义正确、缓存一致性正确、性能收益可量化。

### How
1. 统一更新内核：
   使用 `enum class njson_update_op { set, push, drop }` 描述动作，
   将参数解析、路径定位、对象/数组更新逻辑收敛到公共函数，
   仅通过 `in_place` 决定“原地更新并返回原 handle”或“复制更新并返回新 handle”。
2. keys 缓存机制：
   - `njson_keys_cache_values[id]` 存缓存 list；
   - `njson_keys_cache_gc_locs[id]` 存 GC protect 位置；
   - `njson_keys_cache_valid[id]` 标记有效性。
3. 生命周期管理：
   - `store_njson_value` 确保缓存表容量同步；
   - `f_njson_free` 主动清理缓存槽并 `s7_gc_unprotect_at`；
   - 可变更新成功后调用 `njson_refresh_keys_cache_if_present` 重算缓存。
4. keys 构造微优化：
   `njson_build_keys_list` 使用 `s7_make_string_with_length`，减少 `strlen` 成本。

### 兼容性说明
1. 兼容保留：`njson-set/push/drop` 的函数式语义不变。
2. 新增能力：`njson-set!/push!/drop!` 提供原地更新路径。
3. 语义注意：对象键“新增”应使用 `push/push!`；`set/set!` 仅更新已存在位置。
4. `njson-keys` 缓存对调用方透明，不改变返回值结构与顺序。

## 验证结果
本次文档编写前已执行：
1. ✅ `xmake b goldfish` 通过。
2. ✅ `bin/goldfish tests/goldfish/liii/njson-test.scm` 通过（`; *** checks *** : 79 correct, 0 failed.`）。
3. ✅ `bin/goldfish bench/njson-bench.scm` 通过（`; *** checks *** : 29 correct, 0 failed.`）。

### 基准结果（本次实测，节选）
- 读取(json-ref): `liii/nlohmann = 433.37x`
- 原地修改对比(liii-set vs njson-set!): `582.25x`
- 原地插入对比(liii-push vs njson-push!+drop!): `194.01x`
- 原地删除对比(liii-drop vs njson-set!+drop!): `84.02x`
- 获取键(json-keys): `liii/nlohmann = 724.66x`
